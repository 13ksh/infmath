<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>점수 차트</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body{
      font-family: Arial, sans-serif; margin:0; background:#fff; color:#333;
      display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
      height:100vh; padding:40px 0;
    }
    h1{ margin-bottom:20px; font-size:1.8rem; text-align:center }
    #chartContainer{ width:60%; max-width:600px; height:500px }
    canvas{ width:100% !important; height:100% !important }
    #comment{ margin-top:20px; font-size:1rem; color:#555; text-align:center; max-width:600px; line-height:1.5 }
  </style>
</head>
<body>
  <h1 id="title">점수 차트</h1>
  <div id="chartContainer"><canvas id="scoreChart"></canvas></div>
  <p id="comment"></p>
<script>
  // --- 안전한 UTF-8 Base64 디코드: 실패하면 null ---
  const base64ToText = (b64) => {
    try {
      // d 파라미터는 encodeURIComponent가 되어 오므로 먼저 풀어봄
      const s = typeof b64 === "string" ? decodeURIComponent(b64) : String(b64);
      return new TextDecoder().decode(Uint8Array.from(atob(s), c => c.charCodeAt(0)));
    } catch { return null; }
  };

  // --- 점수 값을 숫자로 변환: (1)Base64 → (2)그냥 숫자 문자열 → (3)그 외 NaN ---
  const toNumber = (v) => {
    if (v == null) return NaN;
    if (typeof v !== "string") v = String(v);
    v = v.trim();
    // 1) Base64 시도
    const maybe = base64ToText(v);
    if (maybe !== null) {
      const n1 = Number(maybe.trim());
      if (Number.isFinite(n1)) return n1;
    }
    // 2) 그냥 숫자 시도
    const n2 = Number(v);
    return Number.isFinite(n2) ? n2 : NaN;
  };

  const params = new URLSearchParams(location.search);
  let user = "사용자", comment = "", labels = [], scores = [];

  if (params.has("d")) {
    // ===== 새 방식: ?d=<base64(JSON)> =====
    const jsonText = base64ToText(params.get("d"));
    if (jsonText !== null) {
      try {
        const payload = JSON.parse(jsonText);
        user = (payload.user ?? user) || user;
        comment = (payload.comment ?? "") || "";
        const items = Array.isArray(payload.items) ? payload.items : [];

        labels = [];
        scores = [];
        items.forEach((it, i) => {
          const label = (it && it.label ? String(it.label) : `점수 ${i+1}`).trim();
          const val = toNumber(it?.score);
          if (Number.isFinite(val)) {   // ★ 유효한 쌍만 push
            labels.push(label);
            scores.push(val);
          }
        });
      } catch (e) {
        console.warn("payload JSON parse error:", e);
      }
    } else {
      console.warn("d param base64 decode failed");
    }
  } else {
    // ===== 구 방식 호환 =====
    user = params.get("user") || user;
    comment = params.get("comment") || "";
    const n = Number(params.get("scorecount")) || 0;
    labels = [];
    scores = [];
    for (let i = 1; i <= n; i++) {
      const label = params.get(`label${i}`) || `점수 ${i}`;
      const num = Number((params.get(`score${i}`) || "").trim());
      if (Number.isFinite(num)) { labels.push(label); scores.push(num); }
    }
  }

  // 제목/멘트
  document.getElementById("title").textContent = `${user}님의 점수 차트`;
  if (comment) document.getElementById("comment").textContent = comment;

  // 디버깅이 필요하면 아래 한 줄 잠깐 풀어서 확인:
  // console.log({labels, scores});

  new Chart(document.getElementById("scoreChart"), {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "점수",
        data: scores,
        backgroundColor: "rgba(54, 162, 235, 0.6)",
        borderColor: "rgba(54, 162, 235, 1)",
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: { y: { beginAtZero: true, min: 0, max: 100 } }
    }
  });
</script>
</body>
</html>




